# # IMPORTANT: This file is generated by cucumber-rails - edit at your own peril.
# # It is recommended to regenerate this file in the future when you upgrade to a 
# # newer version of cucumber-rails. Consider adding your own code to a new file 
# # instead of editing this one. Cucumber will automatically load all features/**/*.rb
# # files.
# 
# 
# require 'uri'
# require 'cgi'
# require File.expand_path(File.join(File.dirname(__FILE__), "..", "support", "paths"))
# 
# module WithinHelpers
#   def with_scope(locator)
#     locator ? within(locator) { yield } : yield
#   end
# end
# World(WithinHelpers)
# 
# Given /^(?:|I )am on (.+)$/ do |page_name|
#   visit path_to(page_name)
# end
# 
# When /^(?:|I )go to (.+)$/ do |page_name|
#   visit path_to(page_name)
# end
# 
# When /^(?:|I )press "([^"]*)"(?: within "([^"]*)")?$/ do |button, selector|
#   with_scope(selector) do
#     click_button(button)
#   end
# end
# 
# When /^(?:|I )follow "([^"]*)"(?: within "([^"]*)")?$/ do |link, selector|
#   with_scope(selector) do
#     click_link(link)
#   end
# end
# 
# When /^(?:|I )fill in "([^"]*)" with "([^"]*)"(?: within "([^"]*)")?$/ do |field, value, selector|
#   with_scope(selector) do
#     fill_in(field, :with => value)
#   end
# end
# 
# When /^(?:|I )fill in "([^"]*)" for "([^"]*)"(?: within "([^"]*)")?$/ do |value, field, selector|
#   with_scope(selector) do
#     fill_in(field, :with => value)
#   end
# end
# 
# # Use this to fill in an entire form with data from a table. Example:
# #
# #   When I fill in the following:
# #     | Account Number | 5002       |
# #     | Expiry date    | 2009-11-01 |
# #     | Note           | Nice guy   |
# #     | Wants Email?   |            |
# #
# # TODO: Add support for checkbox, select og option
# # based on naming conventions.
# #
# When /^(?:|I )fill in the following(?: within "([^"]*)")?:$/ do |selector, fields|
#   with_scope(selector) do
#     fields.rows_hash.each do |name, value|
#       When %{I fill in "#{name}" with "#{value}"}
#     end
#   end
# end
# 
# When /^(?:|I )select "([^"]*)" from "([^"]*)"(?: within "([^"]*)")?$/ do |value, field, selector|
#   with_scope(selector) do
#     select(value, :from => field)
#   end
# end
# 
# When /^(?:|I )check "([^"]*)"(?: within "([^"]*)")?$/ do |field, selector|
#   with_scope(selector) do
#     check(field)
#   end
# end
# 
# When /^(?:|I )uncheck "([^"]*)"(?: within "([^"]*)")?$/ do |field, selector|
#   with_scope(selector) do
#     uncheck(field)
#   end
# end
# 
# When /^(?:|I )choose "([^"]*)"(?: within "([^"]*)")?$/ do |field, selector|
#   with_scope(selector) do
#     choose(field)
#   end
# end
# 
# When /^(?:|I )attach the file "([^"]*)" to "([^"]*)"(?: within "([^"]*)")?$/ do |path, field, selector|
#   with_scope(selector) do
#     attach_file(field, path)
#   end
# end
# 
# Then /^(?:|I )should see JSON:$/ do |expected_json|
#   require 'json'
#   expected = JSON.pretty_generate(JSON.parse(expected_json))
#   actual   = JSON.pretty_generate(JSON.parse(response.body))
#   expected.should == actual
# end
# 
# # Then /^(?:|I )should see "([^"]*)"(?: within "([^"]*)")?$/ do |text, selector|
# #   with_scope(selector) do
# #     if page.respond_to? :should
# #       page.should have_content(text)
# #     else
# #       assert page.has_content?(text)
# #     end
# #   end
# # end
# 
# Then /^I should see "(.*)"$/ do |text|
#   assert !!(response_body =~ /#{Regexp.escape text}/m), response_body
# end
# 
# # Then /^(?:|I )should see \/([^\/]*)\/(?: within "([^"]*)")?$/ do |regexp, selector|
# #   regexp = Regexp.new(regexp)
# #   with_scope(selector) do
# #     if page.respond_to? :should
# #       page.should have_xpath('//*', :text => regexp)
# #     else
# #       assert page.has_xpath?('//*', :text => regexp)
# #     end
# #   end
# # end
# 
# Then /^(?:|I )should not see "([^"]*)"(?: within "([^"]*)")?$/ do |text, selector|
#   with_scope(selector) do
#     if page.respond_to? :should
#       page.should have_no_content(text)
#     else
#       assert page.has_no_content?(text)
#     end
#   end
# end
# 
# Then /^(?:|I )should not see \/([^\/]*)\/(?: within "([^"]*)")?$/ do |regexp, selector|
#   regexp = Regexp.new(regexp)
#   with_scope(selector) do
#     if page.respond_to? :should
#       page.should have_no_xpath('//*', :text => regexp)
#     else
#       assert page.has_no_xpath?('//*', :text => regexp)
#     end
#   end
# end
# 
# Then /^the "([^"]*)" field(?: within "([^"]*)")? should contain "([^"]*)"$/ do |field, selector, value|
#   with_scope(selector) do
#     field = find_field(field)
#     field_value = (field.tag_name == 'textarea') ? field.text : field.value
#     if field_value.respond_to? :should
#       field_value.should =~ /#{value}/
#     else
#       assert_match(/#{value}/, field_value)
#     end
#   end
# end
# 
# Then /^the "([^"]*)" field(?: within "([^"]*)")? should not contain "([^"]*)"$/ do |field, selector, value|
#   with_scope(selector) do
#     field = find_field(field)
#     field_value = (field.tag_name == 'textarea') ? field.text : field.value
#     if field_value.respond_to? :should_not
#       field_value.should_not =~ /#{value}/
#     else
#       assert_no_match(/#{value}/, field_value)
#     end
#   end
# end
# 
# Then /^the "([^"]*)" checkbox(?: within "([^"]*)")? should be checked$/ do |label, selector|
#   with_scope(selector) do
#     field_checked = find_field(label)['checked']
#     if field_checked.respond_to? :should
#       field_checked.should be_true
#     else
#       assert field_checked
#     end
#   end
# end
# 
# Then /^the "([^"]*)" checkbox(?: within "([^"]*)")? should not be checked$/ do |label, selector|
#   with_scope(selector) do
#     field_checked = find_field(label)['checked']
#     if field_checked.respond_to? :should
#       field_checked.should be_false
#     else
#       assert !field_checked
#     end
#   end
# end
#  
# Then /^(?:|I )should be on (.+)$/ do |page_name|
#   current_path = URI.parse(current_url).path
#   if current_path.respond_to? :should
#     current_path.should == path_to(page_name)
#   else
#     assert_equal path_to(page_name), current_path
#   end
# end
# 
# Then /^(?:|I )should have the following query string:$/ do |expected_pairs|
#   query = URI.parse(current_url).query
#   actual_params = query ? CGI.parse(query) : {}
#   expected_params = {}
#   expected_pairs.rows_hash.each_pair{|k,v| expected_params[k] = v.split(',')} 
#   
#   if actual_params.respond_to? :should
#     actual_params.should == expected_params
#   else
#     assert_equal expected_params, actual_params
#   end
# end
# 
# Then /^show me the page$/ do
#   save_and_open_page
# end


require File.expand_path(File.join(File.dirname(__FILE__), "..", "support", "paths"))

# Commonly used webrat steps
# http://github.com/brynary/webrat

Given /^Debug$/ do
  puts response_body
  filepath = '/tmp/webrat_debug.html'
  File.open(filepath, "w") do |file|
    file.puts response_body
  end
  raise "Debugged! Current URL: #{current_url}\nResponse saved: #{filepath}"
end

Given /^I am on(?: the)* (.+)$/ do |page_name|    # assign the variable in second parenthesis to page_name
  visit path_to(page_name)
end


When /^I press "([^\"]*)"$/ do |button|
  click_button(button)
end

# ?: makes parenthesis group without saving the result (don't create a backreference)
When /^I follow|click(?: the)* "([^\"]*)"(?: link)*$/ do |link|
  click_link(link)
end

When /^I fill in "([^\"]*)" with "([^\"]*)"$/ do |field, value|
  fill_in(field, :with => value) 
end

When /^I select "([^\"]*)" from "([^\"]*)"$/ do |value, field|
  select(value, :from => field) 
end

# Use this step in conjunction with Rail's datetime_select helper. For example:
# When I select "December 25, 2008 10:00" as the date and time 
When /^I select "([^\"]*)" as the date and time$/ do |time|
  select_datetime(time)
end

# Use this step when using multiple datetime_select helpers on a page or 
# you want to specify which datetime to select. Given the following view:
#   <%= f.label :preferred %><br />
#   <%= f.datetime_select :preferred %>
#   <%= f.label :alternative %><br />
#   <%= f.datetime_select :alternative %>
# The following steps would fill out the form:
# When I select "November 23, 2004 11:20" as the "Preferred" date and time
# And I select "November 25, 2004 10:30" as the "Alternative" date and time
When /^I select "([^\"]*)" as the "([^\"]*)" date and time$/ do |datetime, datetime_label|
  select_datetime(datetime, :from => datetime_label)
end

# Use this step in conjunction with Rail's time_select helper. For example:
# When I select "2:20PM" as the time
# Note: Rail's default time helper provides 24-hour time-- not 12 hour time. Webrat
# will convert the 2:20PM to 14:20 and then select it. 
When /^I select "([^\"]*)" as the time$/ do |time|
  select_time(time)
end

# Use this step when using multiple time_select helpers on a page or you want to
# specify the name of the time on the form.  For example:
# When I select "7:30AM" as the "Gym" time
When /^I select "([^\"]*)" as the "([^\"]*)" time$/ do |time, time_label|
  select_time(time, :from => time_label)
end

# Use this step in conjunction with Rail's date_select helper.  For example:
# When I select "February 20, 1981" as the date
When /^I select "([^\"]*)" as the date$/ do |date|
  select_date(date)
end

# Use this step when using multiple date_select helpers on one page or
# you want to specify the name of the date on the form. For example:
# When I select "April 26, 1982" as the "Date of Birth" date
When /^I select "([^\"]*)" as the "([^\"]*)" date$/ do |date, date_label|
  select_date(date, :from => date_label)
end

When /^I check "([^\"]*)"$/ do |field|
  check(field) 
end

When /^I check by value "([^\"]*)"$/ do |value|
  xpath = "//input[@value='#{value}']"
  check(field_by_xpath(xpath))
end


When /^I uncheck "([^\"]*)"$/ do |field|
  uncheck(field) 
end

When /^I choose "([^\"]*)"$/ do |field|
  choose(field)
end

When /^I attach the file at "([^\"]*)" to "([^\"]*)"$/ do |path, field|
  attach_file(field, path)
end

Then /^I should see "(.*)"$/ do |text|
  assert !!(response_body =~ /#{Regexp.escape text}/m), response_body
end

Then /^I should not see "(.*)"$/ do |text|
  assert !!(response_body !~ /#{Regexp.escape text}/m), response_body
end

Then /^the "(.*)" checkbox should not be checked$/ do |label|
  assert !field_labeled(label).checked?
end

Then /^the "(.*)" checkbox should be checked$/ do |label|
  assert field_labeled(label).checked?
end

Then /^I should be redirected to "(.*)"$/ do |path|
  assert_template path
end

Then /^the "([^\"]*)" field should contain "([^\"]*)"$/ do |field, value|
  assert field_labeled(field).value =~ /#{value}/
end

Then /^the "([^\"]*)" field should not contain "([^\"]*)"$/ do |field, value|
  assert !(field_labeled(field).value =~ /#{value}/)
end
    
Then /^I should be on (.+)$/ do |page_name|
  assert_equal path_to(page_name), URI.parse(current_url).path
end

